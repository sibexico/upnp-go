# **upnp-go**

Implementation of the uPNP port forwarding in PURE standard Go without dependencies. Advanced features for maximum reliability was implemented. It mostly covered with tests as well.

## **Features**

* **Multi-Interface Discovery:** It will finds your router, even on computer with multiple network interfaces (Ethernet, Wi-Fi, VPN, etc).  
* **Port Forwarding:** Easily forward and clear TCP and UDP ports.  
* **External IP Retrieval:** Discovering your network's public IP address.  
* **Resilient:** Support non-standard and quirky UPnP implementations found in many routers.  
* **Context-Aware:** All network operations support context.Context for cancellation and timeouts.

## **Installation**

go get github.com/sibexico/upnp-go

## **Usage Example**

Here is a simple example that discovers your router, forwards a port for a web server, prints the public URL, and then cleans up the port forwarding rule on exit.


**This example was generated by the Gemini AI for test how well neural network can understand the package.** Neural network made the completely working code, so you can do it too then. :)

```
package main

import (  
	"fmt"  
	"log"  
	"net/http"

	"\[github.com/sibexico/upnp-go\](https://github.com/sibexico/upnp-go)"  
)

func main() {  
	log.Println("--- UPnP Port Forwarding Example \---")

	// 1\. Discover the gateway  
	log.Println("Discovering UPnP-enabled gateway...")  
	igd, err := upnp.Discover()  
	if err \!= nil {  
		log.Fatalf("Failed to discover gateway: %v", err)  
	}  
	log.Printf("Gateway found at: %s", igd.Location())

	// 2\. Get the external IP address  
	log.Println("Retrieving external IP address...")  
	externalIP, err := igd.ExternalIP()  
	if err \!= nil {  
		log.Fatalf("Failed to get external IP: %v", err)  
	}  
	log.Printf("Your public IP is: %s", externalIP)

	// 3\. Forward a port  
	port := uint16(8080)  
	description := "Example Go Web Server"  
	log.Printf("Forwarding port %d...", port)  
	err \= igd.Forward(port, description)  
	if err \!= nil {  
		log.Fatalf("Failed to forward port: %v", err)  
	}  
	log.Printf("Port %d forwarded successfully.", port)

	// 4\. Ensure the port is cleared when the program exits  
	defer func() {  
		log.Printf("Clearing port mapping for port %d...", port)  
		err := igd.Clear(port)  
		if err \!= nil {  
			log.Printf("Failed to clear port: %v", err)  
		} else {  
			log.Println("Port mapping cleared.")  
		}  
	}()

	// 5\. Start a simple web server on the forwarded port  
	http.HandleFunc("/", func(w http.ResponseWriter, r \*http.Request) {  
		fmt.Fprintf(w, "Hello from the other side\!")  
	})

	log.Println("-------------------------------------------")  
	log.Printf("Your server is now accessible from the internet\!")  
	log.Printf("Connect to: http://%s:%d", externalIP, port)  
	log.Println("-------------------------------------------")  
	log.Println("Press Enter to stop the server and clear the port mapping...")

	// The web server runs in a separate goroutine  
	go func() {  
		if err := http.ListenAndServe(fmt.Sprintf(":%d", port), nil); err \!= nil {  
			log.Fatalf("Failed to start web server: %v", err)  
		}  
	}()

	// Wait for user input to exit  
	fmt.Scanln()  
}
```


## **Error Handling**

All public methods return an error. You should always check the returned error to handle it properly.

## **License**

This project is licensed under the MIT License.